<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Free Online Solitaire (Klondike) — Play in Your Browser</title>
  <meta name="description" content="Play classic Klondike Solitaire online for free. Fast, clean, and mobile-friendly. No download, no signup." />

  <meta name="robots" content="index,follow" />

  <!-- Canonical: use the REAL URL of this page -->
  <link rel="canonical" href="https://federicobonessi.github.io/solitaire/" />

  <!-- Open Graph for sharing -->
  <meta property="og:title" content="Free Online Solitaire (Klondike)" />
  <meta property="og:description" content="Play classic Solitaire online for free. Clean UI, fast gameplay, no download." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://federicobonessi.github.io/solitaire/" />

  <!-- Optional: nicer previews on Twitter/X -->
  <meta name="twitter:card" content="summary" />

  <!-- (Optional but recommended) favicon -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' font-size='90'%3E%F0%9F%83%8F%3C/text%3E%3C/svg%3E">
</head>

<section style="max-width:820px;margin:40px auto;line-height:1.6;opacity:.9">
  <h2>Play Classic Klondike Solitaire</h2>
  <p>
    This is a free, browser-based Klondike Solitaire game. Move cards in descending order while alternating colors,
    and build the four foundation piles from Ace to King.
  </p>

  <h2>How to Play</h2>
  <ul>
    <li>In the tableau, place cards in descending order, alternating red and black.</li>
    <li>Only Kings can be moved to empty tableau columns.</li>
    <li>Build foundations by suit from Ace to King.</li>
    <li>Use the stock to draw new cards when you need moves.</li>
  </ul>
</section>

</head>
<body>
  <h1>Solitaire Lite</h1>

  <div class="bar">
    <button id="newBtn">New Game</button>
  </div>

  <!-- Top row: Stock + Waste + Foundations -->
  <div class="row">
    <div class="slot">
      <div class="slotTitle">Stock</div>
      <div id="stock" class="stack"></div>
    </div>

    <div class="slot">
      <div class="slotTitle">Waste</div>
      <div id="waste" class="stack"></div>
    </div>

    <div class="slot">
      <div class="slotTitle">♥</div>
      <div id="fH" class="stack"></div>
    </div>
    <div class="slot">
      <div class="slotTitle">♦</div>
      <div id="fD" class="stack"></div>
    </div>
    <div class="slot">
      <div class="slotTitle">♣</div>
      <div id="fC" class="stack"></div>
    </div>
    <div class="slot">
      <div class="slotTitle">♠</div>
      <div id="fS" class="stack"></div>
    </div>
  </div>

  <!-- Tableau -->
  <div class="row" id="tableauRow"></div>

  <div class="hint" id="msg">Click Stock to draw. Click a card to select, then click destination.</div>

<script>
  // ---- Data ----
  const SUITS = [
    {sym:"♥", color:"red"}, {sym:"♦", color:"red"},
    {sym:"♣", color:"black"}, {sym:"♠", color:"black"}
  ];
  const RANKS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];

  let stock = [];
  let waste = [];
  let foundations = {"♥":[], "♦":[], "♣":[], "♠":[]};
  let tableau = [[],[],[],[],[],[],[]];

  // selected = {from:"waste"|"tableau"|"foundation", col?, idx?}
  let selected = null;

  const elStock = document.getElementById("stock");
  const elWaste = document.getElementById("waste");
  const elFH = document.getElementById("fH");
  const elFD = document.getElementById("fD");
  const elFC = document.getElementById("fC");
  const elFS = document.getElementById("fS");
  const elMsg = document.getElementById("msg");
  const elTableauRow = document.getElementById("tableauRow");

  function setMsg(t){ elMsg.textContent = t; }

  function makeDeck(){
    const deck = [];
    for (const s of SUITS){
      for (let i=0;i<RANKS.length;i++){
        deck.push({
          rank:RANKS[i],
          value:i+1,
          suit:s.sym,
          color:s.color,
          faceUp:false
        });
      }
    }
    // shuffle Fisher-Yates
    for (let i=deck.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  }

  function newGame(){
    const deck = makeDeck();
    stock = deck;
    waste = [];
    foundations = {"♥":[], "♦":[], "♣":[], "♠":[]};
    tableau = [[],[],[],[],[],[],[]];
    selected = null;

    // deal tableau 1..7, last faceUp
    for (let col=0; col<7; col++){
      for (let k=0; k<=col; k++){
        const c = stock.pop();
        tableau[col].push(c);
      }
      tableau[col][tableau[col].length-1].faceUp = true;
    }

    setMsg("New game. Click Stock to draw.");
    render();
  }

  // ---- Rules ----
  function canPlaceOnTableau(moving, destTop){
    // empty column => only King
    if (!destTop) return moving.value === 13;
    // alternating colors + descending by 1
    return moving.color !== destTop.color && moving.value === destTop.value - 1;
  }

  function canPlaceOnFoundation(moving, suitStack){
    // must match suit
    if (suitStack.suit && moving.suit !== suitStack.suit) return false;
    // empty => Ace
    if (suitStack.cards.length === 0) return moving.value === 1;
    const top = suitStack.cards[suitStack.cards.length-1];
    return moving.value === top.value + 1;
  }

  function topCardOfTableau(col){
    const arr = tableau[col];
    if (arr.length === 0) return null;
    return arr[arr.length-1];
  }

  function flipIfNeeded(col){
    const arr = tableau[col];
    if (arr.length === 0) return;
    const top = arr[arr.length-1];
    if (!top.faceUp) top.faceUp = true;
  }

  // ---- Actions ----
  function drawFromStock(){
    if (stock.length === 0){
      // recycle waste into stock
      stock = waste.reverse().map(c => ({...c, faceUp:false}));
      waste = [];
      setMsg("Recycled waste back into stock.");
      selected = null;
      render();
      return;
    }
    const c = stock.pop();
    c.faceUp = true;
    waste.push(c);
    setMsg("Drew a card.");
    selected = null;
    render();
  }

  function select(source){
    selected = source;
    render();
  }

  function clearSelect(){
    selected = null;
    render();
  }

  function moveFromWasteToTableau(col){
    if (waste.length === 0) return;
    const moving = waste[waste.length-1];
    const destTop = topCardOfTableau(col);
    if (!canPlaceOnTableau(moving, destTop)){
      setMsg("Invalid move to tableau.");
      return;
    }
    waste.pop();
    tableau[col].push(moving);
    setMsg("Moved waste → tableau.");
    clearSelect();
  }

  function moveFromWasteToFoundation(suit){
    if (waste.length === 0) return;
    const moving = waste[waste.length-1];
    const suitStack = {suit, cards: foundations[suit]};
    if (!canPlaceOnFoundation(moving, suitStack)){
      setMsg("Invalid move to foundation.");
      return;
    }
    waste.pop();
    foundations[suit].push(moving);
    setMsg("Moved waste → foundation.");
    clearSelect();
  }

  function moveFromTableauToTableau(fromCol, toCol){
    const fromArr = tableau[fromCol];
    if (fromArr.length === 0) return;
    const moving = fromArr[fromArr.length-1];
    if (!moving.faceUp) return;

    const destTop = topCardOfTableau(toCol);
    if (!canPlaceOnTableau(moving, destTop)){
      setMsg("Invalid move.");
      return;
    }
    fromArr.pop();
    tableau[toCol].push(moving);
    flipIfNeeded(fromCol);
    setMsg("Moved tableau → tableau.");
    clearSelect();
  }

  function moveFromTableauToFoundation(fromCol, suit){
    const fromArr = tableau[fromCol];
    if (fromArr.length === 0) return;
    const moving = fromArr[fromArr.length-1];
    if (!moving.faceUp) return;

    const suitStack = {suit, cards: foundations[suit]};
    if (!canPlaceOnFoundation(moving, suitStack)){
      setMsg("Invalid move to foundation.");
      return;
    }
    fromArr.pop();
    foundations[suit].push(moving);
    flipIfNeeded(fromCol);
    setMsg("Moved tableau → foundation.");
    clearSelect();
  }

  // ---- Render ----
  function cardEl(card, isSelected){
    const d = document.createElement("div");
    d.className = "card " + (card.color === "red" ? "red" : "black");
    if (!card.faceUp) d.classList.add("down");
    if (isSelected) d.classList.add("selected");

    const top = document.createElement("div");
    top.className = "corner";
    top.textContent = card.rank + "\n" + card.suit;

    const mid = document.createElement("div");
    mid.className = "mid";
    mid.textContent = card.suit;

    const bot = document.createElement("div");
    bot.className = "corner bottom";
    bot.textContent = card.rank + "\n" + card.suit;

    d.appendChild(top); d.appendChild(mid); d.appendChild(bot);
    return d;
  }

  function render(){
    // STOCK
    elStock.innerHTML = "";
    const stockCard = document.createElement("div");
    stockCard.className = "card down";
    stockCard.style.position = "absolute";
    stockCard.style.left = "6px";
    stockCard.style.top = "6px";
    stockCard.style.marginTop = "0";
    stockCard.onclick = drawFromStock;
    // show stock only if there are cards (else still clickable to recycle)
    elStock.style.position = "relative";
    elStock.appendChild(stockCard);

    // WASTE (only top card visible)
    elWaste.innerHTML = "";
    elWaste.style.position = "relative";
    if (waste.length > 0){
      const top = waste[waste.length-1];
      const isSel = selected && selected.from === "waste";
      const c = cardEl(top, isSel);
      c.style.top = "6px"; c.style.left = "6px"; c.style.marginTop = "0";
      c.onclick = () => {
        if (selected && selected.from === "waste") clearSelect();
        else select({from:"waste"});
      };
      elWaste.appendChild(c);
    }

    // FOUNDATIONS
    const map = {"♥":elFH, "♦":elFD, "♣":elFC, "♠":elFS};
    for (const suit of Object.keys(foundations)){
      const host = map[suit];
      host.innerHTML = "";
      host.style.position = "relative";
      const stack = foundations[suit];
      if (stack.length > 0){
        const top = stack[stack.length-1];
        const c = cardEl(top, false);
        c.style.top="6px"; c.style.left="6px"; c.style.marginTop="0";
        host.appendChild(c);
      }
      host.onclick = () => {
        if (!selected) return;
        if (selected.from === "waste") moveFromWasteToFoundation(suit);
        if (selected.from === "tableau") moveFromTableauToFoundation(selected.col, suit);
      };
    }

    // TABLEAU columns
    elTableauRow.innerHTML = "";
    tableau.forEach((colCards, colIndex) => {
      const slot = document.createElement("div");
      slot.className = "slot";
      const title = document.createElement("div");
      title.className = "slotTitle";
      title.textContent = "Col " + (colIndex+1);
      const stack = document.createElement("div");
      stack.className = "stack";
      stack.style.position = "relative";

      // click empty column destination
      slot.onclick = (e) => {
        if (e.target !== slot && e.target !== title && e.target !== stack) return;
        if (!selected) return;
        if (selected.from === "waste") moveFromWasteToTableau(colIndex);
        if (selected.from === "tableau") moveFromTableauToTableau(selected.col, colIndex);
      };

      colCards.forEach((card, i) => {
        const isTop = i === colCards.length-1;
        const isSel = selected && selected.from==="tableau" && selected.col===colIndex;

        const c = cardEl(card, isTop && isSel);
        c.style.top = (6 + i*22) + "px";
        c.style.left = "6px";
        c.style.marginTop = "0";

        // Only top face-up card is clickable/selectable
        if (isTop && card.faceUp){
          c.onclick = (ev) => {
            ev.stopPropagation();
            if (selected && selected.from==="tableau" && selected.col===colIndex) clearSelect();
            else select({from:"tableau", col:colIndex});
          };
        } else {
          c.style.cursor = "default";
        }
        stack.appendChild(c);
      });

      slot.appendChild(title);
      slot.appendChild(stack);
      elTableauRow.appendChild(slot);
    });
  }

  document.getElementById("newBtn").addEventListener("click", newGame);
  newGame();
</script>
</body>
</html>
